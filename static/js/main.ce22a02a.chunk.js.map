{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/Client.js","../../src/ApiContext.js","../../src/hooks/useApiClient.js","../../src/hooks/useRequest.js","../../src/hooks/useRequestHandler.js","../../src/hooks/useLazyGet.js","../../src/hooks/useGet.js","constants.js","App.js","../../src/hooks/usePost.js","reportWebVitals.js","index.js"],"names":["Symbol","iterator","asyncIterator","JSON_ACCEPT_HEADERS","Object","Client","this","options","mode","cache","redirect","referrerPolicy","response","bind","getHeaders","json","headers","Accept","request","path","query","body","baseUrl","method","url","recover","result","e","then","fetch","JSON","data","status","statusText","res","acceptType","getOr","ApiContext","React","ApiProvider","children","client","useState","value","setValue","PropTypes","isRequired","useApiClient","useContext","setData","cacheKey","params","useEffect","Error","resetData","writeData","key","fetchClient","getParams","getQuery","useRequest","loading","setLoading","error","setError","callback","err","get","useRequestHandler","fetchOptions","mergedOptions","merge","requestOptions","isEmpty","useLazyGet","accessTokenKey","App","clientId","window","sessionStorage","getItem","clientSecret","setParams","githubAccessToken","onChange","preventDefault","setItem","target","name","page","setPage","process","ACCESS_TOKEN_EXCHANGE_SERVER","onCompleted","access_token","location","href","pathname","replace","onError","alert","getAccessToken","per_page","clear","reload","fetchRepos","reposLoading","userRepos","includes","callbackCode","queryString","parse","search","code","client_id","client_secret","redirect_uri","className","map","repo","id","disabled","onClick","onSubmit","stringifyUrl","scope","htmlFor","required","type","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","Authorization","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ce22a02a.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import queryString from 'query-string';\nimport { getOr } from 'lodash/fp';\n\nconst JSON_ACCEPT_HEADERS = Object.freeze([\n  'application/json',\n  'application/vnd.github.v3+json',\n]);\n\nclass Client {\n  constructor(baseUrl, options) {\n    this.baseUrl = baseUrl;\n    this.headers = options.headers;\n    this.options = {\n      mode: 'cors',\n      cache: 'no-cache',\n      redirect: 'follow',\n      referrerPolicy: 'no-referrer',\n    };\n    this.response = this.response.bind(this);\n  }\n\n  getHeaders(json = false) {\n    const headers = this.headers();\n    if (json) {\n      return {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        ...headers,\n      };\n    }\n    return headers;\n  }\n\n  async request({\n    path, query, body, json, baseUrl, method,\n  }) {\n    const url = queryString.stringifyUrl({\n      url: `${baseUrl || this.baseUrl}${path}`,\n      query,\n    });\n    try {\n      const res = await fetch(url, {\n        ...this.options,\n        method,\n        headers: this.getHeaders(json),\n        body: JSON.stringify(body),\n      });\n      return this.response(res);\n    } catch (e) {\n      return { data: e.message, status: 500, statusText: 'Internal server error' };\n    }\n  }\n\n  async response(res) {\n    const acceptType = getOr('', 'Accept', this.getHeaders());\n    let data = null;\n    if (JSON_ACCEPT_HEADERS.includes(acceptType)) {\n      data = await res.json();\n    } else {\n      data = await res.text();\n    }\n    return {\n      status: res.status,\n      statusText: res.statusText,\n      data,\n    };\n  }\n}\n\nexport default Client;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport Client from './Client';\n\nconst ApiContext = React.createContext({});\n\nexport const ApiProvider = ({ children, client }) => {\n  const [value, setValue] = useState({});\n\n  return (\n    <ApiContext.Provider value={{ value, setValue, client }}>\n      {children}\n    </ApiContext.Provider>\n  );\n};\n\nApiProvider.propTypes = {\n  // eslint-disable-next-line react/forbid-prop-types\n  children: PropTypes.any.isRequired,\n  client: PropTypes.instanceOf(Client).isRequired,\n};\nexport default ApiContext;\n","import { useContext, useEffect } from 'react';\nimport ApiContext from '../ApiContext';\n\nconst useApiClient = () => {\n  const { value, setValue, client } = useContext(ApiContext);\n  const setData = (data) => {\n    setValue({\n      ...value,\n      ...data,\n    });\n  };\n\n  const cacheKey = (path, { params, method }) => JSON.stringify({\n    path,\n    params,\n    method,\n  });\n\n  useEffect(() => {\n    if (!client) {\n      throw new Error('Client not set, make sure the hooks are called insider the provider');\n    }\n  }, [client]);\n\n  const resetData = () => setValue({});\n\n  const writeData = (path, { params, data, method }) => {\n    const key = cacheKey(path, { params, method });\n    setData({ [key]: data });\n  };\n\n  return {\n    data: value,\n    cacheKey,\n    setData,\n    resetData,\n    writeData,\n    fetchClient: client,\n  };\n};\n\nexport default useApiClient;\n","import { getOr, merge, isEmpty } from 'lodash/fp';\nimport useApiClient from './useApiClient';\nimport useRequestHandler from './useRequestHandler';\n\nconst getParams = getOr({}, 'params');\nconst getQuery = getOr({}, 'query');\nconst getHeaders = getOr({}, 'headers');\n\nconst useRequest = (path, options = {}) => {\n  const { fetchClient } = useApiClient();\n  const {\n    loading, request, error, data,\n  } = useRequestHandler(path, options);\n\n  const fetch = (fetchOptions) => {\n    const mergedOptions = merge(options, fetchOptions);\n    const requestOptions = {\n      ...options,\n      path,\n      headers: getHeaders(fetchOptions),\n    };\n    if (!isEmpty(getQuery(mergedOptions))) {\n      requestOptions.query = getQuery(mergedOptions);\n    }\n    if (!isEmpty(getParams(mergedOptions))) {\n      requestOptions.body = getParams(mergedOptions);\n    }\n    request(() => fetchClient.request(requestOptions));\n  };\n\n  return [fetch, { loading, data, error }];\n};\n\nexport default useRequest;\n","import { useEffect, useState } from 'react';\nimport { get, getOr } from 'lodash/fp';\nimport useApiClient from './useApiClient';\n\nconst useRequestHandler = (path, options = {}) => {\n  const { cacheKey, data, setData } = useApiClient();\n  const method = getOr('GET', 'method', options);\n  const [loading, setLoading] = useState(options.loading || false);\n  const [error, setError] = useState(null);\n  const key = cacheKey(`${getOr('', 'baseUrl')(options)}${path}`, {\n    params: options.params,\n    query: options.query,\n    method,\n  });\n\n  const request = (callback) => {\n    setLoading(true);\n    callback().then((res) => {\n      if (res.status < 200 || res.status >= 299) {\n        setError(res);\n        setLoading(false);\n      } else {\n        setData({ [key]: res.data });\n      }\n    }).catch((err) => {\n      setError(err.message);\n      setLoading(false);\n    });\n  };\n\n  useEffect(() => {\n    if (loading) {\n      setLoading(false);\n      if (options.onCompleted) {\n        options.onCompleted(data[key]);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [data, key]);\n\n  useEffect(() => {\n    if (error && options.onError) {\n      options.onError(error);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [error]);\n\n  return {\n    cacheKey: key,\n    request,\n    loading,\n    error,\n    data: get(key, data),\n  };\n};\n\nexport default useRequestHandler;\n","import useRequest from './useRequest';\n\nconst useLazyGet = (path, options = {}) => useRequest(path, {\n  ...options,\n  method: 'GET',\n});\n\nexport default useLazyGet;\n","import { useEffect } from 'react';\nimport { getOr } from 'lodash/fp';\nimport useLazyGet from './useLazyGet';\n\nconst getParams = getOr({}, 'query');\n\nconst useGet = (path, options = {}) => {\n  const [fetch, {\n    fetchMore, loading, error, data,\n  }] = useLazyGet(path, {\n    ...options,\n    loading: true,\n  });\n\n  useEffect(() => {\n    fetch(options);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [JSON.stringify(getParams(options))]);\n\n  return {\n    loading,\n    data,\n    error,\n    fetchMore,\n  };\n};\n\nexport default useGet;\n","export const accessTokenKey = 'github_access_token';\nexport const callbackUrl = 'http://localhost:3000/callback';\nexport const perPage = 10;","import { usePost, useLazyGet } from 'rest-api-react-client';\nimport { isEmpty } from 'lodash/fp';\nimport queryString from 'query-string';\nimport './App.css';\nimport { useState, useEffect } from 'react';\nimport { accessTokenKey, callbackUrl, perPage } from './constants';\n\nconst App = () => {\n  const [params, setParams] = useState({\n    clientId: window.sessionStorage.getItem('clientId') || '',\n    clientSecret: window.sessionStorage.getItem('clientSecret') || '',\n  });\n  const githubAccessToken = window.sessionStorage.getItem(accessTokenKey);\n  const onChange = (e) => {\n    e.preventDefault();\n    window.sessionStorage.setItem(e.target.name, e.target.value);\n    setParams({\n      ...params,\n      [e.target.name]: e.target.value,\n    });\n  };\n  const [page, setPage] = useState(1);\n\n  const onNext = () => {\n    setPage(page + 1);\n  }\n\n  const onPrevious = () => {\n    setPage(page - 1);\n  }\n\n  const [getAccessToken, { loading }] = usePost('/github_access_token', {\n    json: true,\n    baseUrl: process.env.ACCESS_TOKEN_EXCHANGE_SERVER,\n    onCompleted(res) {\n      if (res.access_token) {\n        window.sessionStorage.setItem(accessTokenKey, res.access_token);\n      }\n      window.location.href = window.location.pathname.replace('callback', '');\n    },\n    onError(err) {\n      alert(err.data);\n      window.location.href = window.location.pathname.replace('callback', '');\n    }\n  });\n\n  const [fetchRepos, { loading: reposLoading, data: userRepos }] = useLazyGet('/user/repos', {\n    json: true,\n    query: {\n      per_page: perPage,\n    },\n    onError(err) {\n      alert(err.data)\n      if (err.status === 401) {\n        window.sessionStorage.clear();\n        window.location.reload();\n      }\n    }\n  });\n\n  const onSubmit = (e) => {\n    e.preventDefault();\n    window.location.href = queryString.stringifyUrl({\n      url: 'https://github.com/login/oauth/authorize',\n      query: {\n        client_id: params.clientId,\n        scope: 'user,repo'\n      }\n    });\n  }\n\n  useEffect(() => {\n    if (window.location.pathname.includes('/callback')) {\n      const callbackCode = queryString.parse(window.location.search).code;\n      if (callbackCode) {\n        getAccessToken({\n          params: {\n            client_id: window.sessionStorage.getItem('clientId'),\n            client_secret: window.sessionStorage.getItem('clientSecret'),\n            code: callbackCode,\n            redirect_uri: callbackUrl,\n          }\n        })\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    if (window.sessionStorage.getItem(accessTokenKey)) {\n      fetchRepos({ query: { page } });\n    }\n  }, [page]);\n\n  return (\n    <div className=\"App\">\n      <h1>Repositories List</h1>\n      {loading || reposLoading ? 'Loading...' : null}\n      {\n        githubAccessToken ? (\n          <>\n            <div>\n              {(userRepos || []).map((repo) => (<div key={repo.id}>Repo Name: {repo.name}</div>))}\n            </div>\n            <button disabled={reposLoading || page === 1} onClick={onPrevious}>Previous</button>\n            <button disabled={isEmpty(userRepos) || reposLoading} onClick={onNext}>Next</button>\n          </>\n        ): (\n          <form onSubmit={onSubmit} method=\"post\">\n            <legend>Github Credentials</legend>\n            <fieldset>\n              <label htmlFor=\"clientId\">Client ID</label>\n              <input required id=\"clientId\" name=\"clientId\" onChange={onChange} type=\"text\" value={params.clientId} />\n            </fieldset>\n            <fieldset>\n              <label htmlFor=\"clientSecret\">Client Secret</label>\n              <input required id=\"clientSecret\" name=\"clientSecret\" type=\"password\" onChange={onChange} value={params.clientSecret} />\n            </fieldset>\n            <input type=\"submit\" value=\"Authroize Github\" />\n          </form>\n        )\n      }\n    </div>\n  );\n}\n\nexport default App;\n","import useRequest from './useRequest';\n\nconst usePost = (path, options = {}) => useRequest(path, {\n  ...options,\n  method: 'POST',\n});\n\nexport default usePost;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { ApiProvider, Client } from 'rest-api-react-client';\nimport { accessTokenKey } from './constants';\n\n\nconst authroizationHeaders = () => {\n  const token = window.sessionStorage.getItem(accessTokenKey);\n  if (!token) {\n    return {};\n  }\n  return {\n    Authorization: `token ${window.sessionStorage.getItem(accessTokenKey)}`\n  };\n}\n\nconst client = new Client('https://api.github.com', {\n  headers: () => ({\n    ...authroizationHeaders(),\n    Accept: 'application/vnd.github.v3+json',\n    'content-type': 'application/json',\n  }),\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <ApiProvider client={client}>\n      <App />\n    </ApiProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}